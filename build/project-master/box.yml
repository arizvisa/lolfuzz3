#cloud-config
#hostname: "unnamed.master"

coreos:
  update:
    reboot-strategy: "etcd-lock"

  etcd2:
    advertise-client-urls: "http://0.0.0.0:4001"
    listen-client-urls: "http://0.0.0.0:4001"

  fleet:
    etcd_servers: "http://0.0.0.0:4001"
    #etcd_key_prefix: "/project-name/fleet"
    etcd_key_prefix: "/fleet"

  units:
    - name: "etcd2.service"
      command: "start"

    - name: "fleet.service"
      command: "start"

    - name: "flanneld.service"
      #command: "stop"
      drop-ins:
        - name: "50-network-config.conf"
          content: |
            [Service]
            ExecStartPre=/usr/bin/etcdctl set /coreos.com/network/config \
                '{ "Network" : "10.1.0.0/16", "SubnetLen" : 28, "SubnetMin" : "10.1.10.0", "SubnetMax" : "10.1.50.0" }'

    - name: "container-build.service"
      command: "start"
      enable: true

      content: |
        [Unit]
        Description=Image-Building Service

        [Service]
        User=root
        Type=oneshot
        RemainAfterExit=yes
        Environment="CONTAINER_DIR=/opt/container"
        ExecStart=/bin/sh -c \
            '/opt/container/build.sh'

        [Install]
        RequiredBy=network-online.target

    - name: "container-load.service"
      command: "start"
      enable: true

      content: |
        [Unit]
        Description=Image-Loading Service
        Wants=container-build.service
        After=container-build.service

        [Service]
        User=root
        Type=oneshot
        RemainAfterExit=yes
        Environment="CONTAINER_DIR=/opt/container"
        ExecStart=/bin/sh -c \
            '/opt/container/load.sh'

        [Install]
        WantedBy=multi-user.target

    - name: "container-image.timer"
      command: "start"
      enable: true

      content: |
        [Unit]
        Description=Image-Synchronization Job
        Requires=container-load.service
        After=container-load.service

        [Timer]
        OnBootSec=30s
        OnUnitActiveSec=60s

        [Install]
        WantedBy=timers.target

    - name: "container-image.service"
      command: "start"
      enable: true

      content: |
        [Unit]
        Description=Image-Synchronization Service
        Requires=container-load.service
        After=container-load.service

        [Service]
        User=root
        Type=oneshot
        Environment="CONTAINER_DIR=/opt/container"
        ExecStart=/bin/sh -c \
            '/opt/container/update.sh'

        [Install]
        RequiredBy=container-image.timer

#    - name: "container-run.service"
#      command: "start"
#      runtime: true
#      content: |
#        [Unit]
#        Description=Container-Test Service
#        Wants=container-build.service
#
#        [Service]
#        User=root
#        Type=oneshot
#        RemainAfterExit=yes
#        ExecStart=/bin/sh -c \
#            '/bin/touch /root/containers-have-been-built'
#
#        [Install]
#        WantedBy=multi-user.target

manage_etc_hosts: "localhost"

write_files:
    - path: "/opt/container/build.sh"
      permissions: "0750"
      owner: "root"
      content: |
        #!/usr/bin/env bash
        # Build images based on the rules within the filesystem
        export PATH=/sbin:/bin:/usr/sbin:/usr/bin
        umask 027

        BUILDDIR=${BUILDDIR:-"$CONTAINER_DIR/build"}
        IMAGEDIR=${IMAGEDIR:-"$CONTAINER_DIR/image"}
        TOOLDIR=${TOOLDIR:-"$CONTAINER_DIR/tools"}

        [ ! -d "$BUILDDIR" ] && printf 'Build-directory "%s" is not found. Nothing needed to be built. Exiting...\n' "$BUILDDIR" && exit 0
        [ ! -d "$IMAGEDIR" ] && mkdir -p "$IMAGEDIR"

        RELEASE_URL=${RELEASE_URL:-"https://github.com/containers/build/releases/download/v0.4.0/acbuild-v0.4.0.tar.gz"}
        RELEASE_FILE="$CONTAINER_DIR/build.sh."$$
        PING_HOST=${PING_HOST:-"4.2.2.1"}

        trap "[ -f \"$RELEASE_FILE\" ] && /bin/rm -f \"$RELEASE_FILE\"; exit" SIGHUP SIGINT SIGTERM

        # Check if `acbuild` exists..
        ACBUILD=`type -P acbuild 2>/dev/null || type -P "$TOOLDIR"/*/acbuild`
        if [ ! -x "$ACBUILD" ]; then
            # If not, then check to see if we can internet...
            printf '`%s` not found on host.\n' 'acbuild' 1>&2
            if ping -c1 -W1 "$PING_HOST" 1>/dev/null; then
                # ...and then download it.
                printf '`%s` not found in path. Atempting to download from "%s".\n' 'acbuild' "$RELEASE_URL" 1>&2
                wget -q -O "$RELEASE_FILE" "$RELEASE_URL"
                mkdir -p "$TOOLDIR"
                tar -xzf "$RELEASE_FILE" -C "$TOOLDIR"
                rm -f "$RELEASE_FILE"
                ACBUILD=`type -P "$TOOLDIR"/*/acbuild`
            # ...otherwise, we can't build. So let's just head out.
            else
                printf 'Unable to locate acbuild tool in path. Skipping automatic image building.' 1>&2
                exit 0
            fi
        fi

        # Handle acbuild rules for .aci files
        cd "$BUILDDIR" && for rule in *:*.acb; do
            [ ! -f "${rule}" ] && continue

            imgfull=`basename "${rule}" .acb`
            imgname=`basename "${imgfull}" | cut -d: -f1`
            imgver=`basename "${imgfull}" | cut -d: -f2`

            imgfile="${imgname}:${imgver}.aci"
            [ -e "$IMAGEDIR/${imgfile}" ] && printf 'Skipping build of %s due to %s already existing.\n' "${imgfull}" "$BUILDDIR/${imgfile}" && continue

            printf 'Building %s using rule %s.\n' "${imgfile}" "$BUILDDIR/${rule}" 1>&2

            # Dispatch to acbuild while appending a `write` command to the rules.
            cat "${rule}" <( printf 'write --overwrite %s\n' "$IMAGEDIR/${imgfile}" ) | "$ACBUILD" script /dev/stdin

            printf 'Successfully built image "%s:%s" at %s.\n' "${imgname}" "${imgver}" "$IMAGEDIR/${imgname}:${imgver}.aci" 1>&2
            printf '%s:%s\n' "${imgname}" "${imgver}"
        done

        # Handle rules for shell-script that emits the container file.
        cd "$BUILDDIR" && for rule in *:*.{aci,oci}.{sh,bash,csh}; do
            [ ! -f "${rule}" ] && continue

            # Figure out how to execute script
            case "${rule}" in
                *.sh) shtype="sh" ;;
                *.bash) shtype="bash" ;;
                *.csh) shtype="csh" ;;
                *) continue ;;
            esac
            imgfile=`basename "${rule}" ."${shtype}"`

            # Figure out the container type that's supposed to be emitted
            case "${imgfile}" in
                *.aci) imgtype='.aci' ;;
                *.oci) imgtype='.oci' ;;
                *)
                    printf 'Unknown image type for script %s. Skipping.\n' "${rule}" 1>&2
                    continue
                    ;;
            esac

            # Extract components from filename.
            imgfull=`basename "${imgfile}" "${imgtype}"`
            imgname=`basename "${imgfull}" | cut -d: -f1`
            imgver=`basename "${imgfull}" | cut -d: -f2`

            imgfile="${imgname}:${imgver}${imgtype}"
            [ -f "$IMAGEDIR/${imgfile}" ] && printf 'Skipping build of %s due to %s already existing.\n' "${imgfull}" "$BUILDDIR/${imgfile}" && continue

            printf 'Found rule for image "%s:%s" at %s.\n' "${imgname}" "${imgver}" "$IMAGEDIR/${imgname}:${imgver}${imgtype}.${shtype}" 1>&2

            imgtemp="$BUILDDIR/${imgfull}.tmp"
            trap "[ -f \"${imgtemp}\" ] && /bin/rm -f \"${imgtemp}\"; exit" SIGHUP SIGINT SIGTERM

            # And now we can execute it..
            if "${shtype}" "$BUILDDIR/${rule}" >| "${imgtemp}"; then
                mv -f "${imgtemp}" "$IMAGEDIR/${imgfile}"
            else
                rm -f "${imgtemp}"
                printf 'Failure while trying to generate image for rule "%s".\n' "${rule}" 1>&2
            fi

            # ..and now we can inform the user that it's there.
            printf 'Successfully built image "%s:%s" at %s.\n' "${imgname}" "${imgver}" "$IMAGEDIR/${imgfile}" 1>&2
            printf '%s:%s\n' "${imgname}" "${imgver}"
        done

    - path: "/opt/container/load.sh"
      permissions: "0750"
      owner: "root"
      content: |
        #!/usr/bin/env bash
        # Add images into the repository using the images available on the filesystem.
        export PATH=/sbin:/bin:/usr/sbin:/usr/bin
        umask 077

        IMAGEDIR=${IMAGEDIR:-"$CONTAINER_DIR/image"}

        if [ ! -d "$IMAGEDIR" ]; then
            printf 'IMAGEDIR (%s) does not exist. Creating it.\n' "$IMAGEDIR" 1>&2
            mkdir -p "$IMAGEDIR"
        fi

        # ripped from stackoverflow.com/questions/4023830
        ver_le()
        {
            [ "$1" = "`echo -e "$1\n$2" | sort -V | head -n1`" ]
        }
        ver_lt()
        {
            [ "$1" = "$2" ] && return 1 || ver_le "$1" "$2"
        }

        # Build all images that aren't in our containers
        cd "$IMAGEDIR" && for file in *:*.{aci,oci}; do
            [ ! -f "${file}" ] && continue

            # Figure out what image type it is.
            case "${file}" in
                *.aci) suffix='.aci' ;;
                *.oci) suffix='.oci' ;;
                *)
                    printf 'Unknown image suffix for file %s. Skipping.\n' "${file}" 1>&2
                    continue
                    ;;
            esac

            # Validate it with actool if it's an .aci file.
            if [ "${suffix}" = ".aci" ]; then
                if actool validate "${file}" 2>/dev/null; then
                    :
                else
                    printf 'Image "%s" is invalid. Skipping it..\n' "${file}" 1>&2
                    continue
                fi
            fi

            # Extract the difference components out of the filename.
            filefull=`basename "${file}" "${suffix}"`
            filename=`basename "${filefull}" | cut -d: -f1`
            filever=`basename "${filefull}" | cut -d: -f2-`

            # If image name exists in the list of current images..
            matched=`rkt image list --full=true --no-legend=true --fields=name,id,importtime | grep "${filename}:" | sort -Vr | head -n1`
            if [ ! -z "${matched}" ]; then

                # ...but the image version is less than the one loaded, then skip it.
                loadedver=`echo -n "${matched}" | cut -d: -f2`
                ver_le "${filever}" "${loadedver}" && continue

                # otherwise, remove it and continue...
                printf 'Removing older image %s : %s < %s.\n' "${filename}" "${loadedver}" "${filever}" 1>&2
                rkt image rm "${filename}:${filever}" 1>&2
            fi

            # Try and load the image insecurely if a signature was found.
            if [ -f "$IMAGEDIR"/"${file}.asc" ]; then
                printf 'Loading image for %s:%s.\n' "${filename}" "${filever}" 1>&2
                res=`rkt image fetch file://"$IMAGEDIR"/"${filefull}${suffix}" 2>/dev/null`
            # Otherwise, load it insecurely.
            else
                printf 'Loading image (insecurely) for %s:%s.\n' "${filename}" "${filever}" 1>&2
                res=`rkt --insecure-options=image image fetch file://"$IMAGEDIR"/"${filefull}${suffix}" 2>/dev/null`
            fi

            [ -z "${res}" ] && printf 'Error loading image %s:%s\n' "${filename}" "${filever}" 1>&2 && continue

            # ..and then output our result.
            printf '%s : %s : %s\n' "${filename}" "${filever}" "${res}"
        done

    - path: "/opt/container/update.sh"
      permissions: "0750"
      owner: "root"
      content: |
        #!/usr/bin/env bash
        # Update images that are in the repository to the latest available
        #   version on the filesystem according to the timestamp.

        export PATH=/sbin:/bin:/usr/sbin:/usr/bin
        umask 077

        IMAGEDIR=${IMAGEDIR:-"$CONTAINER_DIR/image"}

        [ ! -d "$IMAGEDIR" ] && printf 'IMAGEDIR (%s) does not exist.\n' "$IMAGEDIR" 1>&2 && exit 1

        # ripped from stackoverflow.com/questions/4023830
        ver_le()
        {
            [ "$1" = "`echo -e "$1\n$2" | sort -V | head -n1`" ]
        }
        ver_lt()
        {
            [ "$1" = "$2" ] && return 1 || ver_le "$1" "$2"
        }

        # Enumerate all images in rkt
        rkt image list --full=true --no-legend=true --fields=id,name,importtime | while read id imgfull ts; do
            [ -z "${id}" ] && continue

            tss=`echo -n "${ts}" | cut -d' ' -f1,2`

            # Extract the different components out of the image list
            imgname=`basename "${imgfull}" | cut -d: -f1`
            imgver=`basename "${imgfull}" | cut -d: -f2`
            imgts=`date +%s -d "${tss}"`

            # Find the image file named $imgname with the newest version.
            file=`ls -1 "$IMAGEDIR/${imgname}:"*.{aci,oci} 2>/dev/null | sort -Vr | head -n1`
            if [ -z "${file}" ]; then
                printf 'No versions for image %s (%s) were found on disk!\n' "${imgname}" "${id}" 1>&2
                continue
            fi

            # Figure out what image type it is.
            case "${file}" in
                *.aci) suffix='.aci' ;;
                *.oci) suffix='.oci' ;;
                *)
                    printf 'Unknown image suffix for file %s. Skipping.\n' "${file}" 1>&2
                    continue
                    ;;
            esac

            filefull=`basename "${file}" "${suffix}"`
            filename=`basename "${filefull}" | cut -d: -f1`
            filever=`basename "${filefull}" | cut -d: -f2`
            filets=`stat -c%Y "${file}"`

            # if versions are the same and the img is newer than the file, then we don't need to update
            [ "${imgver}" = "${filever}" -a "${filets}" -le "${imgts}" ] && continue

            # assert that the file version is >= the image version
            if ver_lt "${filever}" "${imgver}"; then
                printf 'Image %s on disk is a lesser version than in image list! (%s < %s)\n' "${filefull}" "${filever}" "${imgver}" 1>&2
                continue
            fi

            # this means that either there's an updated version, or a newer timestamp
            if [ "${imgver}" != "${filever}" ]; then
                printf 'Image %s:%s (%s) needs to be updated to version %s.\n' "${imgname}" "${imgver}" "${id}" "${filever}" 1>&2
            else
                printf 'Image %s:%s needs to be synced with %s. (%s)\n' "${imgname}" "${imgver}" "${filefull}" "${id}" 1>&2
            fi

            # so remove the image from rkt if it's not running...
            task_count=`rkt list --full=true --no-legend=true | cut -f3,5 | grep "^${imgname}:" | grep $'\t'"running$" | wc -l`
            if [ "${task_count}" -gt 0 ]; then
                printf 'Refusing to remove image %s:%s as it'\''s still in use!\n' "${imgname}" "${imgver}" 1>&2
            else
                printf 'Removing old image %s:%s due to it not being in use.\n' "${imgname}" "${imgver}" 1>&2
                rkt image rm "${id}" 1>&2
            fi

            # ...and then fe-fetch it securely if a signature was found.
            if [ -f "$IMAGEDIR"/"${imgname}:${imgver}.asc" ]; then
                printf 'Loading image (secrely) for %s:%s.\n' "${filename}" "${filever}" 1>&2
                res=`rkt image fetch file://"${file}"`
            # ...and insecurely if not.
            else
                printf 'Loading image (insecurely) for %s:%s.\n' "${filename}" "${filever}" 1>&2
                res=`rkt --insecure-options=image image fetch file://"${file}"`
            fi

            [ -z "${res}" ] && printf 'Error loading image %s:%s\n' "${filename}" "${filever}" 1>&2 && continue

            printf '%s : %s : %s\n' "${filename}" "${filever}" "${res}"
        done

    - path: "/srv/.empty"
      permissions: "0644"
      owner: "root"
